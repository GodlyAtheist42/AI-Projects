''' 
A program to solve the 11-puzzle using the A* algorithm with graph search. The heuristic
used is the sum of Manhattan distances of the tiles from their positions in the goal state.
'''
ROW = 3
COLUMN = 4

class State: #Class to represent states generated by the algorithm
    def __init__(self, pos, parent = None, prevAction = "", costToState = 0, noOfChildren = 0):
        self.numPos = pos #1-D array representing the positions of all the numbers
        self.emptyCoords = self.index("0")//COLUMN, self.index("0")%COLUMN #Position of the "empty" tile
        self.fn = 0 #Integer representing the f(n) value of the current state
        self.parent = parent #Keeping track of the parent to help with backtracking
        self.prevAction = prevAction #Action that the algorithm made to achieve this state 
        self.costToState = costToState #The cumulative cost of reaching the state
        self.noOfChildren = noOfChildren #The number of children that the state generates on expanding

    #Method to calculate f(n). Here g(n) = costToState and h(n) = Manhattan Sum of the current state
    def calculatefn(self, goalState):
        self.fn = self.costToState + self.manhattanSum(goalState)
    
    #Metod to calculate the Manhattan Sum (h(n)) of the current state given goal state
    def manhattanSum(self, goalState):
        manhSum = 0
        for num in self:
            if int(num):
                manhattanDist = abs(goalState.index(num)//COLUMN - self.index(num)//COLUMN) +\
                abs(goalState.index(num)%COLUMN - self.index(num)%COLUMN)
                manhSum += manhattanDist
        return manhSum
    
    #Generator to generate the children of the given state
    def createNextStates(self):
        emptyCoords = self.emptyCoords
        actualIndex = emptyCoords[0]*COLUMN + emptyCoords[1]
        ecList = [(emptyCoords[0],emptyCoords[1]-1), (emptyCoords[0], emptyCoords[1]+1), (emptyCoords[0]-1, emptyCoords[1]), (emptyCoords[0]+1, emptyCoords[1])] 
        actions = ["L", "R", "U", "D"]
        for i, ec in enumerate(ecList):
            if 0 <= ec[0] < ROW  and 0 <= ec[1] < COLUMN: #Making sure the new state is valid
                self.noOfChildren += 1 #Useful in calculating the total nodes generated
                newPos = self.numPos[:]
                toSwap = ec[0]*COLUMN + ec[1]
                newPos[actualIndex], newPos[toSwap] = newPos[toSwap], newPos[actualIndex]
                newState = State(newPos, self, actions[i], self.costToState+1)
                yield newState

    #Accessor
    def __getitem__(self, i):
        return self.numPos[i]
    
    #Mutator
    def __setitem__(self, i, val):
        self.numPos[i] = val

    #Iterator to make the code a bit simpler
    def __iter__(self):
        for i in self.numPos:
            yield i
    
    #Operator overloading to check for equality
    def __eq__(self, other):
        return self.numPos == other.numPos

    #Utility to make the code a bit simpler
    def index(self, i):
        return self.numPos.index(i)

#Function to read the input from the file and parse the data
def readInput():
    fileName = input("Input file name to read from: ") #Take input
    file = open(fileName, "r")

    #The states are saved in 1D arrays even though they represent 2D matrices. The indices for the numbers
    #can be counted using simple arithmetic
    initialPos = [num for _ in range(ROW) for num in file.readline().split()]
    initialState = State(initialPos)
    file.readline()
    goalPos = [num for _ in range(ROW) for num in file.readline().split()]
    goalState = State(goalPos)
    return initialState, goalState

#Utility to select the next state to expand. The one with the smallest f(n) will be expanded next.
def selectNextState(states):
    minState = states[0]
    for state in states:
        if state.fn < minState.fn:
            minState = state
    return minState

#Function containing the actual loop for the algorithm
def runHeuristic(initialState, goalState):
    visitedStates = [] #States that have been expanded are moved to this list
    frontier = [initialState] #This list contains all the states that are yet to be expanded
    initialState.calculatefn(goalState) #Calculating the f(n) of the initial state
    nodesGenerated = 1 #Variable to keep track of the total number of nodes generated
    while True:
        currState = selectNextState(frontier) #The state with the smallest f(n) is selected to be expanded
        if currState == goalState: #Checking if the goal state has been reached
            return currState,nodesGenerated
        for child in currState.createNextStates(): #If not, generate the state's children
            child.calculatefn(goalState) #Calculate the f(n) of the state
            if child not in visitedStates: #Add state to frontier only if it has not already been expanded
                frontier.append(child)
            else:
                #If a child is already in visited states, remove the state with the higher f(n) from the tree
                oldState = None    
                for state in visitedStates:
                    if state == child:
                        oldState = state
                if oldState.fn < child.fn:
                    child.parent = None
                else:
                    oldState.parent = None 

        nodesGenerated += currState.noOfChildren #Update total no. of nodes based on no. of children generated
        frontier.remove(currState) #Remove current state from frontier
        visitedStates.append(currState) #Mark the state as "explored"

#Utility to write the output to a file
def writeOutput(finalState, nodesGenerated):
    actionList = []; fnList = []
    currState = finalState
    depth = currState.costToState #Depth is equal to the cumulative cost since action cost is 1
    while currState.parent: #Backtrack from the final state to get action sequence and f(n)s for all states
        actionList.append(currState.prevAction)
        fnList.append(currState.fn)
        currState = currState.parent
    fnList.append(currState.fn)
    initialState = currState
    #The sequences need to be reversed to get them in the right order
    actionList = actionList[::-1]
    fnList = fnList[::-1]
    
    #Code to write the required data to the file
    fileName = input("Input file name to write to: ")
    file = open(fileName, "w")
    
    for i in range(ROW):
        file.write(" ".join(initialState[i*COLUMN:i*COLUMN + COLUMN]) + "\n")
    file.write("\n")
    for i in range(ROW):
        file.write(" ".join(finalState[i*COLUMN:i*COLUMN + COLUMN]) + "\n")
    file.write("\n" + str(depth) + "\n" + str(nodesGenerated) + "\n")
    file.write(" ".join(actionList)+"\n") 
    file.write(" ".join([str(i) for i in fnList]))

initialState,goalState = readInput()
finalState, nodesGenerated = runHeuristic(initialState, goalState)
writeOutput(finalState, nodesGenerated)